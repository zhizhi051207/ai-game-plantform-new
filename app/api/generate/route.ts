import { NextRequest, NextResponse } from "next/server";
import OpenAI from "openai";
import { createGame } from "@/lib/db";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth-options";

export const runtime = "nodejs";


// 初始化OpenAI客户端，连接到OpenRouter
const openai = new OpenAI({
  baseURL: "https://openrouter.ai/api/v1",
  apiKey: process.env.OPENROUTER_API_KEY,
  defaultHeaders: {
    "HTTP-Referer": process.env.NEXTAUTH_URL || "http://localhost:3000",
    "X-Title": "AI Game Generator",
  },
});

export async function POST(request: NextRequest) {
  try {
    // 获取用户会话（要求认证）
    const session = await getServerSession(authOptions);
    console.log("=== GENERATE API SESSION DEBUG ===");
    console.log("Full session data:", JSON.stringify(session, null, 2));
    console.log("Session exists:", !!session);
    console.log("Session user:", session?.user);
    console.log("Session user email:", session?.user?.email);
    console.log("Session user id:", session?.user?.id);
    
    if (!session?.user?.email) {
      console.log("ERROR: No session or email found - returning 401");
      return NextResponse.json(
        { 
          error: "Authentication required",
          debug: {
            hasSession: !!session,
            hasUser: !!session?.user,
            hasEmail: !!session?.user?.email
          }
        },
        { status: 401 }
      );
    }
    console.log("SUCCESS: User authenticated:", session.user.email, "User ID:", session.user.id);

    const { prompt } = await request.json();
    if (!prompt || typeof prompt !== "string") {
      return NextResponse.json({ error: "Prompt is required" }, { status: 400 });
    }

    // 检查API密钥
    if (!process.env.OPENROUTER_API_KEY) {
      console.error("OpenRouter API key is missing");
      return NextResponse.json(
        { error: "Server configuration error" },
        { status: 500 }
      );
    }



    const normalizeHtml = (content: string) => {
      let result = content.trim();
      if (result.startsWith("```")) {
        result = result
          .replace(/^```[a-zA-Z]*\n?/, "")
          .replace(/```\s*$/, "")
          .trim();
      }
      return result;
    };

    const isHtmlComplete = (content: string) => {
      const lower = content.toLowerCase();
      return lower.includes("</html>") || lower.includes("</body>");
    };

    const createCompletion = () =>
      openai.chat.completions.create({
        model: "google/gemini-3-flash-preview",
        provider: { order: ["google-ai-studio"] },
        messages: [
          {
            role: "system",
            content: `请生成一个可完整运行的「单文件 HTML 小游戏」，必须满足以下条件：

【硬性要求】
1) 输出必须是一个完整、可直接运行的 HTML 文件（内嵌 CSS + JS）
3) 输出内容只允许包含 HTML 代码本体：不要解释说明、不要 Markdown、不要 
 代码块
4) 尽量多使用Tailwind CSS、GSAP、Framer Motion、DaisyUI 等开源库来简化代码

【游戏类型与定位】
5) 游戏要求：${prompt}
6) 整体必须统一、有设计感（例如：可爱、卡通、极简、科技风等任一明确方向）
7) UI 必须美观好看，具备良好的视觉层级、对比度与动效反馈，避免"纯功能界面"

【视觉与动效设计（重点强化）】
8) 所有核心界面元素必须具备“设计感”：
   - 使用圆角、阴影、渐变、模糊（backdrop-filter）、发光等现代 UI 手法
   - 重要 UI（分数、血量、Combo）需有视觉强调，而非普通文字
9) 页面整体需具备“活着的感觉”：
   - 背景可包含轻微动态（渐变流动、粒子、呼吸动画等）
   - 元素进入 / 出现 / 消失需使用平滑动画（fade / scale / slide / spring）

【核心互动体验（必须具备）】
8) 击中反馈明确且有表现力：
   - 命中目标时有粒子 / 缩放 / 震动 / 颜色变化等视觉反馈
   - 分数以浮动文字或动画形式展示
10) 目标或敌人必须具备"被互动感"：
    - 被击中会有形变 / 状态变化 / 表情变化 / 动作反馈
    - 不只是简单消失
11) UI 与玩家操作之间必须有即时响应：
    - 按钮 hover / 点击有动画反馈
    - 数值、进度条变化必须平滑过渡

【操作与玩法】
12) 操作方式尽量直观：
    - 鼠标点击或键盘触发核心动作
    - 如引入移动（WASD / 方向键），必须保持轻量与易上手
13) 目标或敌人至少包含 2–3 种不同类型：
    - 不同分值 / 行为 / 风险
    - 难度随时间或关卡递增

【技术与性能】
20) 桌面 Chrome 可流畅运行；画面自适应窗口；目标约 60fps
21) 如果实现难度过高，优先级为：
    可运行性 > 互动反馈 > 视觉复杂度 > 真实 3D 精度

【输出格式】
22) 最终只输出完整 HTML 源码（包含 <html>…</html>），不要输出任何解释文字
23) 必须有restart game 按钮
24) 界面不能只由简单像素立方体组成！
`,
          },
          {
            role: "user",
            content: `游戏需求：${prompt}`,
          },
        ],
        temperature: 0.7,
        max_tokens: 8192,
      } as any);

    const extractContent = (completion: any) =>
      completion?.choices?.[0]?.message?.content || "";

    console.log("Calling Gemini 3 Flash Preview with prompt:", prompt.substring(0, 100));
    const completion = await createCompletion();
    let htmlContent = extractContent(completion);

    if (!htmlContent) {
      console.error("No content generated by AI. Completion payload:", JSON.stringify(completion));
      throw new Error("No content generated by AI");
    }

    htmlContent = normalizeHtml(htmlContent);

    if (!isHtmlComplete(htmlContent)) {
      console.warn("Generated HTML incomplete, retrying once...");
      const retryCompletion = await createCompletion();
      let retryContent = retryCompletion.choices[0].message.content || "";
      retryContent = normalizeHtml(retryContent);
      if (isHtmlComplete(retryContent)) {
        htmlContent = retryContent;
      }
    }

    console.log("Game generated successfully, length:", htmlContent.length);

    // 创建游戏记录到数据库
    const game = await createGame({
      title: prompt.substring(0, 50) + (prompt.length > 50 ? "..." : ""),
      description: `AI-generated game from prompt: ${prompt}`,
      prompt,
      htmlContent,
      isPublic: true,
      userId: session.user.email, // 使用邮箱确保存在用户记录
    });

    return NextResponse.json({
      success: true,
      gameId: game.id,
      title: game.title,
      htmlContent: game.htmlContent,
      message: "Game generated successfully!",
    });
  } catch (error: any) {
    console.error("Game generation error:", error);

    // 提供更详细的错误信息
    let errorMessage = "Failed to generate game";
    if (error.code === 403) {
      errorMessage = "The selected model is not available in your region or there is an issue with your OpenRouter account.";
    } else if (error.message?.includes("API key")) {
      errorMessage = "Invalid OpenRouter API key. Please check your configuration.";
    } else if (error.message?.includes("model")) {
      errorMessage = "Model configuration error. Please check if OpenAI GPT-5.1-Codex-Mini (openai/gpt-5.1-codex-mini) is available on OpenRouter.";
    }


    return NextResponse.json(
      {
        error: errorMessage,
        details: error.message || String(error),
        code: error.code,
      },
      { status: 500 }
    );
  }
}